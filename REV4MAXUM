/*
ESP32 Dual-Core Tensile Machine - Refactored Edition
- Improved NAU7802 load cell integration with robust error handling
- Clean separation of concerns with dedicated classes
- Professional data acquisition with 80Hz sampling
- Enhanced calibration and diagnostic systems
- Thread-safe circular buffer implementation
*/

#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include <EEPROM.h>
#include "driver/gpio.h"
#include "soc/gpio_reg.h"
#include "SparkFun_Qwiic_Scale_NAU7802_Arduino_Library.h"

// ===== HARDWARE CONFIGURATION =====
// Display
Adafruit_SH1107 display = Adafruit_SH1107(64, 128, &Wire);

// Load Cell
NAU7802 myScale;

// GPIO Pins
const int DIR = 16;
const int STEP = 15;
const int EN = 14;
#define BUTTON_A 9
#define BUTTON_B 6
#define BUTTON_C 5

// Motor Parameters
const int MICRO_STEPS = 8;
const int GEAR_RATIO = 50;
const int MOTOR_STEPS_PER_REV = 200 * MICRO_STEPS;
const int OUTPUT_STEPS_PER_REV = MOTOR_STEPS_PER_REV * GEAR_RATIO;

// Mechanical Parameters
const float MM_PER_REV = 8.0f;
const float MM_PER_STEP = MM_PER_REV / OUTPUT_STEPS_PER_REV;

// EEPROM Configuration (matching SparkFun examples)
#define EEPROM_SIZE 100
#define LOCATION_CALIBRATION_FACTOR 0
#define LOCATION_ZERO_OFFSET 10
#define LOCATION_SETTINGS_VALID 20

// ===== LOAD CELL CONFIGURATION CLASS =====
class LoadCellConfig {
public:
    static const uint8_t DEFAULT_GAIN = 16;
    static const uint8_t SAMPLE_RATE = 80;  // Hz
    static const uint8_t CALIBRATION_SAMPLES = 64;
    static const uint16_t MAX_WAIT_MS = 50;  // Max wait for data availability
    static constexpr float SATURATION_THRESHOLD = 8000000.0f;  // 24-bit ADC near max
    static constexpr float MAX_REASONABLE_WEIGHT_KG = 1000.0f;  // Sanity check
};

// ===== DATA STRUCTURES =====
struct TestDataPoint {
    uint64_t timestamp_us;
    float force_N;
    float position_mm;
    uint32_t step_count;
    bool valid;
};

struct LiveTestData {
    float currentForce_N;
    float peakForce_N;
    float currentPosition_mm;
    uint32_t totalSteps;
    uint64_t testStartTime_us;
    bool testActive;
    bool scaleCalibrated;
    bool bufferOverflow;
    bool sensorSaturated;
    bool scaleError;
};

enum SystemState {
    STATE_MENU_MAIN,
    STATE_MENU_LOAD_CELL,
    STATE_JOG,
    STATE_TEST,
    STATE_ULTIMATE_RESULT
};

enum TestMode {
    TEST_ULTIMATE = 0,
    TEST_GRAPH = 1,
    TEST_FATIGUE = 2,
    TEST_CREEP = 3
};

// ===== GLOBAL VARIABLES =====
// Data Buffer
#define BUFFER_SIZE 1000
#define MAX_TEST_DURATION_POINTS (BUFFER_SIZE * 10)
TestDataPoint dataBuffer[BUFFER_SIZE];
volatile uint16_t bufferWriteIndex = 0;
volatile bool bufferWrapped = false;
volatile uint32_t totalDataPoints = 0;

// Live Data
LiveTestData liveData = {0};

// FreeRTOS
EventGroupHandle_t testEventFlags;
#define EVT_TEST_START       (1 << 0)
#define EVT_TEST_STOP        (1 << 1)
#define EVT_CALIBRATE_START  (1 << 2)
#define EVT_CALIBRATE_DONE   (1 << 3)
#define EVT_TARE_REQUEST     (1 << 4)
#define EVT_DATA_READY       (1 << 5)

// Hardware Timer
hw_timer_t* stepTimer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

// Motor Control (volatile for ISR access)
volatile bool moveStepper = false;
volatile uint32_t stepperSpeed = 1000;
volatile bool stepperDir = true;
volatile uint32_t stepsTaken = 0;
volatile uint16_t totalRotations = 0;
volatile bool motorEnabled = true;
volatile bool stepState = false;
volatile bool timerRunning = false;
volatile int32_t jogStepCounter = 0;

// Task Handles
TaskHandle_t uiTaskHandle = NULL;
TaskHandle_t dataTaskHandle = NULL;

// UI State
SystemState currentState = STATE_MENU_MAIN;
uint8_t menuIndex = 0;
uint8_t blinkCounter = 0;
float jogDistanceMM = 0.0f;

// Configuration
float jogRateOptions[] = {0.2f, 0.4f, 0.8f};
uint8_t jogRateIndex = 0;
float testRate_mmps = 0.2f;
TestMode currentTestMode = TEST_ULTIMATE;
const uint8_t mainMenuItemCount = 6;
const uint8_t loadCellMenuItemCount = 5;

// Button Debounce
unsigned long lastDebounceA = 0, lastDebounceB = 0, lastDebounceC = 0;

// ===== LOAD CELL MANAGER CLASS =====
class LoadCellManager {
private:
    bool initialized = false;
    uint32_t lastErrorTime = 0;
    uint32_t consecutiveErrors = 0;
    
public:
    bool initialize() {
        Serial.println("Initializing NAU7802 load cell...");
        
        // Initialize I2C
        Wire.begin();
        Wire.setClock(400000);
        
        if (!myScale.begin()) {
            Serial.println("‚ùå NAU7802 not detected - check wiring");
            return false;
        }
        
        Serial.println("‚úì NAU7802 detected");
        
        // Configure in proper sequence
        if (!configure()) {
            Serial.println("‚ùå NAU7802 configuration failed");
            return false;
        }
        
        initialized = true;
        Serial.println("‚úì NAU7802 initialized successfully");
        return true;
    }
    
    bool configure() {
        // Set gain (16x is stable default)
        myScale.setGain(NAU7802_GAIN_16);
        
        // Set sample rate for 80Hz
        myScale.setSampleRate(NAU7802_SPS_80);
        
        // Set LDO voltage
        myScale.setLDO(NAU7802_LDO_3V0);
        
        // CRITICAL: Calibrate AFE after configuration changes
        Serial.println("Calibrating AFE...");
        if (!myScale.calibrateAFE()) {
            Serial.println("AFE calibration failed");
            return false;
        }
        
        // Wait for stabilization
        delay(500);
        
        Serial.println("‚úì NAU7802 configured: 16x gain, 80 SPS, 3.0V LDO");
        return true;
    }
    
    bool loadCalibration() {
        if (!initialized) return false;
        
        float calibrationFactor;
        int32_t zeroOffset;
        bool settingsValid;
        
        // Load settings valid flag
        EEPROM.get(LOCATION_SETTINGS_VALID, settingsValid);
        if (!settingsValid) {
            Serial.println("No valid calibration found in EEPROM");
            return false;
        }
        
        // Load calibration factor
        EEPROM.get(LOCATION_CALIBRATION_FACTOR, calibrationFactor);
        if (isnan(calibrationFactor) || calibrationFactor <= 0) {
            Serial.println("Invalid calibration factor in EEPROM");
            return false;
        }
        
        // Load zero offset
        EEPROM.get(LOCATION_ZERO_OFFSET, zeroOffset);
        
        // Apply to NAU7802
        myScale.setCalibrationFactor(calibrationFactor);
        myScale.setZeroOffset(zeroOffset);
        
        Serial.printf("‚úì Loaded calibration: factor=%.3f, offset=%ld\n", 
                      calibrationFactor, zeroOffset);
        
        return true;
    }
    
    void saveCalibration() {
        if (!initialized) return;
        
        EEPROM.put(LOCATION_CALIBRATION_FACTOR, myScale.getCalibrationFactor());
        EEPROM.put(LOCATION_ZERO_OFFSET, myScale.getZeroOffset());
        
        bool settingsValid = true;
        EEPROM.put(LOCATION_SETTINGS_VALID, settingsValid);
        
        EEPROM.commit();
        Serial.println("‚úì Calibration saved to EEPROM");
    }
    
    bool performCalibration() {
        if (!initialized) {
            Serial.println("Load cell not initialized");
            return false;
        }
        
        Serial.println("\n=== LOAD CELL CALIBRATION ===");
        Serial.println("This load cell supports both TENSION and COMPRESSION");
        
        // Step 1: Zero calibration
        Serial.println("Step 1: Remove all weight/load from load cell");
        Serial.println("Press Enter when ready...");
        waitForUserInput();
        
        Serial.println("Zeroing scale (64 samples)...");
        myScale.calculateZeroOffset(LoadCellConfig::CALIBRATION_SAMPLES);
        Serial.printf("Zero offset: %ld\n", myScale.getZeroOffset());
        
        // Step 2: Weight calibration
        Serial.println("\nStep 2: Apply known load to load cell");
        Serial.println("For TENSION: Hang a known weight (e.g., 20kg)");
        Serial.println("For COMPRESSION: Place/push known weight (e.g., 20kg)");
        Serial.println("Press Enter when load is stable...");
        waitForUserInput();
        
        Serial.print("Enter load value (e.g., 20 for 20kg): ");
        
        // FIXED: Better serial input handling
        String weightStr = "";
        while (Serial.available()) Serial.read(); // Clear buffer
        
        while (weightStr.length() == 0) {
            while (Serial.available() == 0) {
                delay(10);
                vTaskDelay(pdMS_TO_TICKS(1));
            }
            
            weightStr = Serial.readStringUntil('\n');
            weightStr.trim();
            
            if (weightStr.length() == 0) {
                Serial.print("Please enter a load value: ");
            }
        }
        
        float knownWeight = weightStr.toFloat();
        
        if (knownWeight <= 0) {
            Serial.println("‚ùå Invalid weight value");
            return false;
        }
        
        Serial.printf("Calibrating with %.2f units...\n", knownWeight);
        
        // Take a raw reading to determine if this is tension or compression
        delay(500);
        if (myScale.available()) {
            int32_t rawReading = myScale.getReading();
            int32_t zeroOffset = myScale.getZeroOffset();
            bool isCompression = (rawReading < zeroOffset);
            
            Serial.printf("Raw reading: %ld, Zero: %ld\n", rawReading, zeroOffset);
            if (isCompression) {
                Serial.println("Detected: COMPRESSION mode (reading < zero)");
            } else {
                Serial.println("Detected: TENSION mode (reading > zero)");
            }
        }
        
        myScale.calculateCalibrationFactor(knownWeight, LoadCellConfig::CALIBRATION_SAMPLES);
        
        // Verify calibration
        delay(1000);
        float testReading = getWeight();
        float error = abs(abs(testReading) - knownWeight);  // Compare absolute values
        
        Serial.printf("‚úì Calibration factor: %.8f\n", myScale.getCalibrationFactor());
        Serial.printf("Test reading: %.3f units\n", testReading);
        Serial.printf("Expected: ¬±%.3f units\n", knownWeight);
        Serial.printf("Error: %.3f units (%.1f%%)\n", error, (error/knownWeight)*100);
        
        if (testReading < 0) {
            Serial.println("‚úì Calibrated for COMPRESSION (negative readings)");
        } else {
            Serial.println("‚úì Calibrated for TENSION (positive readings)");
        }
        
        if (error / knownWeight > 0.05) { // 5% error threshold
            Serial.println("‚ö†Ô∏è  Warning: High calibration error - check setup");
        } else {
            Serial.println("‚úì Calibration successful!");
        }
        
        saveCalibration();
        Serial.println("=== CALIBRATION COMPLETE ===\n");
        return true;
    }
    
    float getWeight() {
        if (!initialized) return 0.0f;
        
        // Simple, clean I2C read without interrupt interference
        if (!myScale.available()) {
            // Don't wait - just return last known value to avoid blocking
            return 0.0f;
        }
        
        // FIXED: Do our own conversion instead of using library's getWeight()
        int32_t rawReading = myScale.getReading();
        
        // Manual conversion: (rawReading - zeroOffset) / calibrationFactor
        int32_t zeroOffset = myScale.getZeroOffset();
        float calibrationFactor = myScale.getCalibrationFactor();
        
        if (calibrationFactor == 0.0f || calibrationFactor == 1.0f) {
            // Invalid calibration
            return 0.0f;
        }
        
        // Calculate weight manually (this is what the library should do)
        float weight = (float)(rawReading - zeroOffset) / calibrationFactor;
        
        // Sanity check (allow negative for compression)
        if (abs(weight) > LoadCellConfig::MAX_REASONABLE_WEIGHT_KG) {
            handleError("Unreasonable weight reading");
            liveData.sensorSaturated = true;
            return 0.0f;
        }
        
        // Reset error counter on successful read
        consecutiveErrors = 0;
        liveData.scaleError = false;
        
        return weight;
    }
    
    float getForceN() {
        return getWeight() * 9.81f; // Convert kg to Newtons
    }
    
    void tare() {
        if (!initialized) return;
        
        Serial.println("Taring scale...");
        myScale.calculateZeroOffset(LoadCellConfig::CALIBRATION_SAMPLES);
        saveCalibration();
        Serial.printf("‚úì New zero offset: %ld\n", myScale.getZeroOffset());
    }
    
    void runDiagnostics() {
        Serial.println("\n=== LOAD CELL DIAGNOSTICS ===");
        
        if (!initialized) {
            Serial.println("‚ùå Load cell not initialized");
            return;
        }
        
        // Test 1: Raw readings stability
        Serial.println("Test 1: Raw readings (10 samples)");
        int32_t readings[10];
        bool allValid = true;
        
        for (int i = 0; i < 10; i++) {
            uint32_t startTime = millis();
            while (!myScale.available() && (millis() - startTime < 100)) {
                delay(1);
            }
            
            if (myScale.available()) {
                readings[i] = myScale.getReading();
                Serial.printf("  %d: %ld\n", i+1, readings[i]);
            } else {
                Serial.printf("  %d: TIMEOUT\n", i+1);
                allValid = false;
            }
            delay(50);
        }
        
        // Calculate stability
        if (allValid) {
            int32_t minVal = readings[0], maxVal = readings[0];
            for (int i = 1; i < 10; i++) {
                if (readings[i] < minVal) minVal = readings[i];
                if (readings[i] > maxVal) maxVal = readings[i];
            }
            Serial.printf("  Range: %ld (lower is better)\n", maxVal - minVal);
        }
        
        // Test 2: Calibrated readings
        Serial.println("\nTest 2: Calibrated readings (5 samples)");
        for (int i = 0; i < 5; i++) {
            float weight = getWeight();
            Serial.printf("  %d: %.3f kg (%.2f N)\n", i+1, weight, weight * 9.81f);
            delay(200);
        }
        
        // Test 3: Configuration status
        Serial.println("\nTest 3: Configuration");
        Serial.printf("  Calibration factor: %.8f\n", myScale.getCalibrationFactor());
        Serial.printf("  Zero offset: %ld\n", myScale.getZeroOffset());
        Serial.printf("  Gain: 16x (assumed)\n");
        Serial.printf("  Sample rate: 80 SPS\n");
        Serial.printf("  Consecutive errors: %lu\n", consecutiveErrors);
        
        Serial.println("=== DIAGNOSTICS COMPLETE ===\n");
    }
    
private:
    void handleError(const char* errorMsg) {
        consecutiveErrors++;
        liveData.scaleError = true;
        
        // Throttle error messages (every 5 seconds)
        if (millis() - lastErrorTime > 5000) {
            Serial.printf("‚ö†Ô∏è  Load cell error: %s (count: %lu)\n", errorMsg, consecutiveErrors);
            lastErrorTime = millis();
        }
        
        // If too many consecutive errors, try to reinitialize
        if (consecutiveErrors > 50) {
            Serial.println("üîÑ Too many errors - attempting reinitialization");
            initialize();
            consecutiveErrors = 0;
        }
    }
    
    void waitForUserInput() {
        while (Serial.available()) Serial.read();
        while (Serial.available() == 0) {
            delay(10);
            vTaskDelay(pdMS_TO_TICKS(1));
        }
        while (Serial.available()) Serial.read();
    }
};

// Global load cell manager instance
LoadCellManager loadCell;

// ===== UTILITY FUNCTIONS =====
uint32_t getStepsTakenSafe() {
    portENTER_CRITICAL(&timerMux);
    uint32_t steps = stepsTaken;
    portEXIT_CRITICAL(&timerMux);
    return steps;
}

const char* getTestModeString(TestMode mode) {
    switch (mode) {
        case TEST_ULTIMATE: return "Ultimate";
        case TEST_GRAPH: return "Graph";
        case TEST_FATIGUE: return "Fatigue";
        case TEST_CREEP: return "Creep";
        default: return "Unknown";
    }
}

// ===== DATA ACQUISITION =====
void recordDataPoint() {
    if (!liveData.testActive) return;
    
    // Check for buffer overflow
    if (totalDataPoints >= MAX_TEST_DURATION_POINTS) {
        liveData.bufferOverflow = true;
        stopTest();
        Serial.println("‚ö†Ô∏è  Test auto-stopped: Maximum data points reached");
        return;
    }
    
    TestDataPoint& point = dataBuffer[bufferWriteIndex];
    point.timestamp_us = esp_timer_get_time() - liveData.testStartTime_us;
    point.force_N = liveData.currentForce_N;
    point.position_mm = liveData.currentPosition_mm;
    point.step_count = getStepsTakenSafe();
    point.valid = true;
    
    bufferWriteIndex = (bufferWriteIndex + 1) % BUFFER_SIZE;
    if (bufferWriteIndex == 0) bufferWrapped = true;
    totalDataPoints++;
    
    xEventGroupSetBits(testEventFlags, EVT_DATA_READY);
}

void printBufferToSerial() {
    Serial.println("=== TEST DATA EXPORT ===");
    Serial.println("Timestamp_us,Force_N,Position_mm,Step_Count");
    
    uint16_t startIndex = bufferWrapped ? bufferWriteIndex : 0;
    uint16_t count = bufferWrapped ? BUFFER_SIZE : bufferWriteIndex;
    
    for (uint16_t i = 0; i < count; i++) {
        uint16_t index = (startIndex + i) % BUFFER_SIZE;
        TestDataPoint& point = dataBuffer[index];
        
        if (point.valid) {
            Serial.printf("%llu,%.3f,%.3f,%lu\n", 
                point.timestamp_us, point.force_N, 
                point.position_mm, point.step_count);
        }
    }
    Serial.println("=== END DATA ===");
}

// ===== HARDWARE TIMER INTERRUPT =====
void IRAM_ATTR stepTimerCallback() {
    portENTER_CRITICAL_ISR(&timerMux);
    if (moveStepper && motorEnabled) {
        stepState = !stepState;
        if (stepState)
            REG_WRITE(GPIO_OUT_W1TS_REG, (1 << STEP));
        else
            REG_WRITE(GPIO_OUT_W1TC_REG, (1 << STEP));

        if (stepState) {
            stepsTaken++;
            jogStepCounter += (stepperDir ? 1 : -1);
            
            if (stepsTaken >= MOTOR_STEPS_PER_REV) {
                stepsTaken = 0;
                totalRotations++;
                if (totalRotations > 30000) totalRotations = 0;
            }
        }
    }
    portEXIT_CRITICAL_ISR(&timerMux);
}

// ===== TIMER FUNCTIONS =====
void startStepTimer(uint32_t sps) {
    if (sps == 0) {
        stopStepTimer();
        return;
    }
    
    if (stepTimer) {
        timerEnd(stepTimer);
        stepTimer = NULL;
        delay(10);
    }
    
    if (sps < 10) sps = 10;
    if (sps > 10000) sps = 10000;
    
    stepTimer = timerBegin(1000000);
    if (!stepTimer) return;
    
    uint64_t alarmValue = 500000 / sps;
    if (alarmValue < 50) alarmValue = 50;
    
    timerAttachInterrupt(stepTimer, &stepTimerCallback);
    timerAlarm(stepTimer, alarmValue, true, 0);
    timerRunning = true;
}

void stopStepTimer() {
    if (stepTimer) {
        timerEnd(stepTimer);
        stepTimer = NULL;
    }
    REG_WRITE(GPIO_OUT_W1TC_REG, (1 << STEP));
    stepState = false;
    timerRunning = false;
}

// ===== MOTION CONTROL =====
void startJog(float rate_mmps) {
    uint32_t sps = rate_mmps / MM_PER_STEP;
    if (sps < 10) sps = 10;
    if (sps > 10000) sps = 10000;
    
    stepperSpeed = sps;
    digitalWrite(DIR, stepperDir);
    startStepTimer(sps);
}

void startTest() {
    liveData.testActive = true;
    liveData.testStartTime_us = esp_timer_get_time();
    liveData.peakForce_N = 0.0f;
    liveData.bufferOverflow = false;
    liveData.sensorSaturated = false;
    bufferWriteIndex = 0;
    bufferWrapped = false;
    totalDataPoints = 0;
    
    stepperDir = true; // Always forward for tests
    moveStepper = true;
    startJog(testRate_mmps);
    
    xEventGroupSetBits(testEventFlags, EVT_TEST_START);
    Serial.printf("üöÄ Test started: %s mode at %.2f mm/s\n", 
                  getTestModeString(currentTestMode), testRate_mmps);
}

void stopTest() {
    liveData.testActive = false;
    moveStepper = false;
    stopStepTimer();
    
    float testDuration_s = (float)(esp_timer_get_time() - liveData.testStartTime_us) / 1000000.0f;
    
    xEventGroupSetBits(testEventFlags, EVT_TEST_STOP);
    Serial.printf("üèÅ Test completed: %.2fs, %lu points, peak %+.2fN\n", 
                  testDuration_s, totalDataPoints, liveData.peakForce_N);
}

// ===== MENU FUNCTIONS =====
const char* getMainMenuLabel(uint8_t index) {
    static char buffer[40];
    switch (index) {
        case 0: return "Jog Mode";
        case 1: snprintf(buffer, sizeof(buffer), "Jog Rate [%.1f mm/s]", jogRateOptions[jogRateIndex]); return buffer;
        case 2: return "Test Mode";
        case 3: snprintf(buffer, sizeof(buffer), "Test Rate [%.1f mm/s]", testRate_mmps); return buffer;
        case 4: snprintf(buffer, sizeof(buffer), "Test Type [%s]", getTestModeString(currentTestMode)); return buffer;
        case 5: return "Load Cell >";
        default: return "";
    }
}

const char* getLoadCellMenuLabel(uint8_t index) {
    static char buffer[40];
    switch (index) {
        case 0: 
            snprintf(buffer, sizeof(buffer), "Status [%s]", 
                    liveData.scaleCalibrated ? "Ready" : "Needs Cal"); 
            return buffer;
        case 1: 
            if (liveData.scaleCalibrated) {
                snprintf(buffer, sizeof(buffer), "Force: %.2f N", liveData.currentForce_N);
            } else {
                snprintf(buffer, sizeof(buffer), "Force: Not Ready");
            }
            return buffer;
        case 2: return "Calibrate Scale";
        case 3: return "Tare Scale";
        case 4: return "< Back to Main";
        default: return "";
    }
}

// ===== TASKS =====
void dataAcquisitionTask(void* pvParameters) {
    Serial.println("üìä Data acquisition task started on Core 1");
    TickType_t lastWakeTime = xTaskGetTickCount();
    const TickType_t frequency = pdMS_TO_TICKS(12); // ~80Hz
    
    for (;;) {
        // Update position and steps (no I2C here - just motor data)
        liveData.currentPosition_mm = jogStepCounter * MM_PER_STEP;
        liveData.totalSteps = getStepsTakenSafe();
        
        // DON'T read scale here - it interferes with timer interrupts
        // Scale reading moved to main loop on Core 0
        
        // Record data during testing (using force value set by main loop)
        if (liveData.testActive) {
            recordDataPoint();
            
            // Ultimate test break detection (works for both tension and compression)
            if (currentTestMode == TEST_ULTIMATE && abs(liveData.peakForce_N) > 5.0f) {
                static float lastForce = 0;
                static uint8_t dropCount = 0;
                
                // Check for force drop (works for both + and - forces)
                bool forceDropped = false;
                if (liveData.peakForce_N > 0) {
                    // Tension mode: check for force drop
                    forceDropped = (liveData.currentForce_N < lastForce * 0.85f);
                } else {
                    // Compression mode: check for force drop (less negative)
                    forceDropped = (liveData.currentForce_N > lastForce * 0.85f);
                }
                
                if (forceDropped) {
                    dropCount++;
                    if (dropCount >= 5) {
                        stopTest();
                        currentState = STATE_ULTIMATE_RESULT;
                    }
                } else {
                    dropCount = 0;
                }
                lastForce = liveData.currentForce_N;
            }
        }
        
        // Handle tare requests
        EventBits_t bits = xEventGroupGetBits(testEventFlags);
        if (bits & EVT_TARE_REQUEST) {
            // Tare request will be handled by main loop
            xEventGroupClearBits(testEventFlags, EVT_TARE_REQUEST);
        }
        
        vTaskDelayUntil(&lastWakeTime, frequency);
    }
}

void uiTask(void* pvParameters) {
    Serial.println("üñ•Ô∏è  UI task started on Core 1");
    for (;;) {
        handleButtons();
        jogDistanceMM = jogStepCounter * MM_PER_STEP;
        updateDisplay();
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

// ===== BUTTON HANDLING =====
void handleButtons() {
    unsigned long now = millis();
    bool a = !digitalRead(BUTTON_A);
    bool b = !digitalRead(BUTTON_B);
    bool c = !digitalRead(BUTTON_C);
    static bool la = false, lb = false, lc = false;

    switch (currentState) {
        case STATE_MENU_MAIN:
            if (a && !la && now - lastDebounceA > 200) {
                lastDebounceA = now;
                menuIndex = (menuIndex + mainMenuItemCount - 1) % mainMenuItemCount;
            }
            if (b && !lb && now - lastDebounceB > 200) {
                lastDebounceB = now;
                menuIndex = (menuIndex + 1) % mainMenuItemCount;
            }
            if (c && !lc && now - lastDebounceC > 200) {
                lastDebounceC = now;
                switch (menuIndex) {
                    case 0: 
                        currentState = STATE_JOG; 
                        jogStepCounter = 0; 
                        break;
                    case 1: 
                        jogRateIndex = (jogRateIndex + 1) % 3; 
                        break;
                    case 2: 
                        if (liveData.scaleCalibrated) {
                            currentState = STATE_TEST; 
                            startTest();
                        }
                        break;
                    case 3: 
                        testRate_mmps += 0.05f; 
                        if (testRate_mmps > 1.0f) testRate_mmps = 0.05f; 
                        break;
                    case 4: 
                        currentTestMode = (TestMode)((currentTestMode + 1) % 2);
                        break;
                    case 5:
                        currentState = STATE_MENU_LOAD_CELL;
                        menuIndex = 0;
                        break;
                }
            }
            break;

        case STATE_MENU_LOAD_CELL:
            if (a && !la && now - lastDebounceA > 200) {
                lastDebounceA = now;
                menuIndex = (menuIndex + loadCellMenuItemCount - 1) % loadCellMenuItemCount;
            }
            if (b && !lb && now - lastDebounceB > 200) {
                lastDebounceB = now;
                menuIndex = (menuIndex + 1) % loadCellMenuItemCount;
            }
            if (c && !lc && now - lastDebounceC > 200) {
                lastDebounceC = now;
                switch (menuIndex) {
                    case 2: // Calibrate
                        if (loadCell.performCalibration()) {
                            liveData.scaleCalibrated = true;
                        }
                        break;
                    case 3: // Tare
                        xEventGroupSetBits(testEventFlags, EVT_TARE_REQUEST);
                        break;
                    case 4: // Back
                        currentState = STATE_MENU_MAIN;
                        menuIndex = 0;
                        break;
                }
            }
            break;

        case STATE_JOG:
            if ((a && !la) || (b && !lb)) {
                moveStepper = false;
                stopStepTimer();
                delay(5);
            }
            
            if (a && !la) {
                lastDebounceA = now;
                stepperDir = false;
                moveStepper = true;
                startJog(jogRateOptions[jogRateIndex]);
            } else if (!a && la) {
                moveStepper = false;
                stopStepTimer();
            }

            if (b && !lb) {
                lastDebounceB = now;
                stepperDir = true;
                moveStepper = true;
                startJog(jogRateOptions[jogRateIndex]);
            } else if (!b && lb) {
                moveStepper = false;
                stopStepTimer();
            }

            if (c && !lc && now - lastDebounceC > 200) {
                lastDebounceC = now;
                moveStepper = false;
                stopStepTimer();
                currentState = STATE_MENU_MAIN;
            }
            break;

        case STATE_TEST:
            if (c && !lc && now - lastDebounceC > 200) {
                lastDebounceC = now;
                stopTest();
                currentState = STATE_MENU_MAIN;
            }
            break;

        case STATE_ULTIMATE_RESULT:
            static uint32_t resultStartTime = 0;
            if (resultStartTime == 0) resultStartTime = millis();
            
            if (millis() - resultStartTime > 10000 || (c && !lc)) {
                resultStartTime = 0;
                currentState = STATE_MENU_MAIN;
            }
            break;
    }

    la = a; lb = b; lc = c;
}

// ===== DISPLAY FUNCTIONS =====
void updateDisplay() {
    display.clearDisplay();
    blinkCounter = (blinkCounter + 1) % 10;
    
    switch (currentState) {
        case STATE_MENU_MAIN:
            drawMainMenu();
            break;
        case STATE_MENU_LOAD_CELL:
            drawLoadCellMenu();
            break;
        case STATE_JOG:
            drawJogScreen();
            break;
        case STATE_TEST:
            drawTestScreen();
            break;
        case STATE_ULTIMATE_RESULT:
            drawResultScreen();
            break;
    }
    display.display();
}

void drawMainMenu() {
    display.fillScreen(SH110X_WHITE);
    display.setTextColor(SH110X_BLACK);
    
    display.setCursor(18, 1);
    display.println("=== MAIN MENU ===");
    display.setCursor(1, 12);
    
    for (uint8_t i = 0; i < mainMenuItemCount; i++) {
        if (i == menuIndex) {
            if (blinkCounter < 5) {
                display.fillRect(0, display.getCursorY(), 128, 8, SH110X_BLACK);
                display.setTextColor(SH110X_WHITE);
                display.print(">");
                display.setCursor(display.getCursorX() + 1, display.getCursorY());
                display.println(getMainMenuLabel(i));
                display.setTextColor(SH110X_BLACK);
            } else {
                display.print(">");
                display.setCursor(display.getCursorX() + 1, display.getCursorY());
                display.println(getMainMenuLabel(i));
            }
        } else {
            display.print(" ");
            display.setCursor(display.getCursorX() + 1, display.getCursorY());
            display.println(getMainMenuLabel(i));
        }
        display.setCursor(1, display.getCursorY() + 1);
    }
}

void drawLoadCellMenu() {
    display.fillScreen(SH110X_BLACK);
    display.setTextColor(SH110X_WHITE);
    
    display.setCursor(18, 1);
    display.println("=== LOAD CELL ===");
    
    // Status indicators
    display.setCursor(1, 12);
    if (liveData.scaleCalibrated) {
        display.print("Status: READY");
        if (liveData.scaleError) display.print(" (ERR)");
    } else {
        display.print("Status: NOT CALIBRATED");
    }
    
    display.setCursor(1, display.getCursorY() + 3);
    for (uint8_t i = 0; i < loadCellMenuItemCount; i++) {
        if (i == menuIndex) {
            if (blinkCounter < 5) {
                display.fillRect(0, display.getCursorY(), 128, 8, SH110X_WHITE);
                display.setTextColor(SH110X_BLACK);
                display.print(">");
                display.setCursor(display.getCursorX() + 1, display.getCursorY());
                display.println(getLoadCellMenuLabel(i));
                display.setTextColor(SH110X_WHITE);
            } else {
                display.print(">");
                display.setCursor(display.getCursorX() + 1, display.getCursorY());
                display.println(getLoadCellMenuLabel(i));
            }
        } else {
            display.print(" ");
            display.setCursor(display.getCursorX() + 1, display.getCursorY());
            display.println(getLoadCellMenuLabel(i));
        }
        display.setCursor(1, display.getCursorY() + 1);
    }
}

void drawJogScreen() {
    display.fillScreen(SH110X_BLACK);
    display.setTextColor(SH110X_WHITE);
    
    display.setCursor(23, 1);
    display.println("=== JOG MODE ===");
    
    display.setCursor(1, 12);
    display.print("Rate: ");
    display.print(jogRateOptions[jogRateIndex]);
    display.println(" mm/s");
    
    display.setCursor(1, display.getCursorY() + 1);
    display.print("Dist: ");
    display.print(jogDistanceMM, 1);
    display.println(" mm");
    
    if (liveData.scaleCalibrated) {
        display.setCursor(1, display.getCursorY() + 1);
        display.print("Force: ");
        display.print(liveData.currentForce_N, 1);
        display.println(" N");
    }
    
    display.setCursor(1, display.getCursorY() + 2);
    display.println("A:REV B:FWD C:EXIT");
}

void drawTestScreen() {
    display.fillScreen(SH110X_BLACK);
    display.setTextColor(SH110X_WHITE);
    
    display.setCursor(20, 1);
    display.println("=== TEST MODE ===");
    
    display.setCursor(1, 12);
    display.print("Type: ");
    display.println(getTestModeString(currentTestMode));
    
    display.setCursor(1, display.getCursorY() + 1);
    display.print("Rate: ");
    display.print(testRate_mmps);
    display.println(" mm/s");
    
    if (liveData.scaleCalibrated) {
        display.setCursor(1, display.getCursorY() + 1);
        display.print("Force: ");
        if (liveData.currentForce_N >= 0) {
            display.print("+");
        }
        display.print(liveData.currentForce_N, 1);
        display.println(" N");
        
        display.setCursor(1, display.getCursorY() + 1);
        display.print("Peak: ");
        if (liveData.peakForce_N >= 0) {
            display.print("+");
        }
        display.print(liveData.peakForce_N, 1);
        display.println(" N");
    }
    
    display.setCursor(1, display.getCursorY() + 1);
    display.print("Pos: ");
    display.print(liveData.currentPosition_mm, 1);
    display.println(" mm");
    
    display.setCursor(1, display.getCursorY() + 1);
    display.print("Data: ");
    display.print(totalDataPoints);
    display.println(" pts");
    
    // Test duration
    if (liveData.testActive) {
        float testTime_s = (float)(esp_timer_get_time() - liveData.testStartTime_us) / 1000000.0f;
        display.setCursor(1, display.getCursorY() + 1);
        display.print("Time: ");
        display.print(testTime_s, 1);
        display.println("s");
    }
    
    // Warnings
    if (liveData.bufferOverflow) {
        display.setCursor(1, display.getCursorY() + 1);
        display.println("! BUFFER FULL !");
    }
    
    if (liveData.sensorSaturated) {
        display.setCursor(1, display.getCursorY() + 1);
        display.println("! SENSOR CLIPPED !");
    }
    
    if (liveData.scaleError) {
        display.setCursor(1, display.getCursorY() + 1);
        display.println("! SCALE ERROR !");
    }
    
    display.setCursor(1, display.getCursorY() + 1);
    display.println("C = STOP");
}

void drawResultScreen() {
    display.fillScreen(SH110X_BLACK);
    display.setTextColor(SH110X_WHITE);
    
    display.setCursor(22, 1);
    display.println("=== RESULTS ===");
    
    display.setCursor(1, 12);
    display.println("ULTIMATE STRENGTH:");
    
    display.setCursor(1, display.getCursorY() + 2);
    display.print("Peak Force: ");
    if (liveData.peakForce_N >= 0) {
        display.print("+");
        display.println("TENSION");
        display.setCursor(1, display.getCursorY());
        display.print(abs(liveData.peakForce_N), 1);
        display.println(" N");
    } else {
        display.print("-");
        display.println("COMPRESSION");
        display.setCursor(1, display.getCursorY());
        display.print(abs(liveData.peakForce_N), 1);
        display.println(" N");
    }
    
    display.setCursor(1, display.getCursorY() + 1);
    display.print("Final Pos: ");
    display.print(liveData.currentPosition_mm, 1);
    display.println(" mm");
    
    display.setCursor(1, display.getCursorY() + 1);
    display.print("Data Points: ");
    display.println(totalDataPoints);
    
    if (liveData.testStartTime_us > 0) {
        float testDuration_s = (float)(esp_timer_get_time() - liveData.testStartTime_us) / 1000000.0f;
        display.setCursor(1, display.getCursorY() + 1);
        display.print("Duration: ");
        display.print(testDuration_s, 1);
        display.println("s");
    }
    
    if (liveData.sensorSaturated) {
        display.setCursor(1, display.getCursorY() + 1);
        display.println("! CLIPPED DATA !");
    }
    
    display.setCursor(1, display.getCursorY() + 2);
    display.println("Auto-return in 10s");
    display.setCursor(1, display.getCursorY() + 1);
    display.println("or press C");
}

// ===== SERIAL COMMAND HANDLING =====
void handleSerialCommand(String command) {
    command.trim();
    command.toLowerCase();
    
    if (command == "help") {
        printHelp();
    }
    else if (command == "status") {
        printStatus();
    }
    else if (command == "calibrate") {
        if (loadCell.performCalibration()) {
            liveData.scaleCalibrated = true;
        }
    }
    else if (command == "tare") {
        loadCell.tare();
    }
    else if (command == "diag") {
        loadCell.runDiagnostics();
    }
    else if (command == "reinit") {
        Serial.println("üîÑ Reinitializing load cell...");
        if (loadCell.initialize()) {
            liveData.scaleCalibrated = loadCell.loadCalibration();
        }
    }
    else if (command == "export") {
        printBufferToSerial();
    }
    else if (command == "test5") {
        Serial.println("5 consecutive readings:");
        for (int i = 0; i < 5; i++) {
            float force = loadCell.getForceN();
            Serial.printf("%d: %.3f N\n", i+1, force);
            delay(200);
        }
    }
    else if (command.startsWith("setcal ")) {
        handleSetCalCommand(command);
    }
    else if (command == "slowdiag") {
        runSlowDiagnostics();
    }
    else if (command == "i2cscan") {
        scanI2CDevices();
    }
    else if (command == "clocktest") {
        testI2CClockSpeeds();
    }
    else if (command == "hardwarereset") {
        performHardwareReset();
    }
    else if (command == "powercycle") {
        performPowerCycle();
    }
    else if (command.startsWith("gain ")) {
        int gain = command.substring(5).toInt();
        testDifferentGain(gain);
    }
    else if (command.startsWith("setgain ")) {
        int gain = command.substring(8).toInt();
        setGainPermanently(gain);
    }
    else if (command == "tensiontest") {
        testTensionCompression();
    }
    else if (command.startsWith("measure ")) {
        int samples = command.substring(8).toInt();
        if (samples <= 0) samples = 100;
        runMeasurementTest(samples);
    }
    else if (command == "measure") {
        runMeasurementTest(100); // Default 100 samples
    }
    else if (command == "reset") {
        Serial.println("üîÑ Restarting system...");
        delay(100);
        esp_restart();
    }
    else {
        Serial.printf("Unknown command: '%s'. Type 'help' for available commands.\n", command.c_str());
    }
}

void handleSetCalCommand(String command) {
    String params = command.substring(7);
    params.trim();
    
    int firstSpace = params.indexOf(' ');
    int secondSpace = params.indexOf(' ', firstSpace + 1);
    
    if (firstSpace > 0) {
        float factor = params.substring(0, firstSpace).toFloat();
        int32_t offset;
        int gain = 16;
        
        if (secondSpace > 0) {
            offset = params.substring(firstSpace + 1, secondSpace).toInt();
            gain = params.substring(secondSpace + 1).toInt();
        } else {
            offset = params.substring(firstSpace + 1).toInt();
        }
        
        if (factor > 0) {
            // Set gain first
            switch (gain) {
                case 1: myScale.setGain(NAU7802_GAIN_1); break;
                case 2: myScale.setGain(NAU7802_GAIN_2); break;
                case 4: myScale.setGain(NAU7802_GAIN_4); break;
                case 8: myScale.setGain(NAU7802_GAIN_8); break;
                case 16: myScale.setGain(NAU7802_GAIN_16); break;
                case 32: myScale.setGain(NAU7802_GAIN_32); break;
                case 64: myScale.setGain(NAU7802_GAIN_64); break;
                case 128: myScale.setGain(NAU7802_GAIN_128); break;
                default:
                    Serial.printf("Invalid gain %d, using 16x\n", gain);
                    myScale.setGain(NAU7802_GAIN_16);
                    gain = 16;
                    break;
            }
            
            // MUST recalibrate AFE after gain change
            if (myScale.calibrateAFE()) {
                Serial.println("‚úì AFE recalibrated after gain change");
            } else {
                Serial.println("‚ö†Ô∏è  AFE calibration failed");
            }
            
            delay(100);
            
            // Apply calibration values
            myScale.setCalibrationFactor(factor);
            myScale.setZeroOffset(offset);
            loadCell.saveCalibration();
            liveData.scaleCalibrated = true;
            
            Serial.printf("‚úì Calibration values set:\n");
            Serial.printf("  Factor: %.8f\n", factor);
            Serial.printf("  Offset: %ld\n", offset);
            Serial.printf("  Gain: %dx\n", gain);
        } else {
            Serial.println("‚ùå Invalid factor value");
        }
    } else {
        Serial.println("Usage: setcal <factor> <offset> [gain]");
    }
}

void printHelp() {
    Serial.println("\n=== TENSILE MACHINE COMMANDS ===");
    Serial.println();
    Serial.println("CALIBRATION:");
    Serial.println("  calibrate - Interactive calibration wizard");
    Serial.println("  setcal <factor> <offset> [gain] - Set values directly");
    Serial.println("  tare - Zero the scale");
    Serial.println();
    Serial.println("BASIC DIAGNOSTICS:");
    Serial.println("  status - Show system status");
    Serial.println("  diag - Run standard load cell diagnostics");
    Serial.println("  test5 - Show 5 consecutive readings");
    Serial.println("  measure [samples] - Detailed accuracy analysis (default: 100)");
    Serial.println("  tensiontest - Test both tension and compression");
    Serial.println("  reinit - Reinitialize load cell");
    Serial.println();
    Serial.println("ADVANCED DIAGNOSTICS:");
    Serial.println("  slowdiag - 30 slow readings with timing analysis");
    Serial.println("  i2cscan - Scan for I2C devices");
    Serial.println("  clocktest - Test different I2C clock speeds");
    Serial.println("  hardwarereset - Reset NAU7802 chip");
    Serial.println("  powercycle - Test power down/up cycle");
    Serial.println("  gain <1-128> - Test specific gain setting (temporary)");
    Serial.println("  setgain <1-128> - Set gain permanently");
    Serial.println();
    Serial.println("DATA:");
    Serial.println("  export - Export test data as CSV");
    Serial.println();
    Serial.println("SYSTEM:");
    Serial.println("  reset - Restart ESP32");
    Serial.println("  help - Show this help");
    Serial.println();
    Serial.println("TROUBLESHOOTING WORKFLOW:");
    Serial.println("  1. i2cscan     - Check I2C communication");
    Serial.println("  2. slowdiag    - Check reading stability");
    Serial.println("  3. measure 200 - Detailed accuracy analysis");
    Serial.println("  4. tensiontest - Test both tension/compression");
    Serial.println("  5. clocktest   - Test I2C speeds");
    Serial.println("  6. gain 1      - Test lowest gain");
    Serial.println("  7. hardwarereset - If all else fails");
    Serial.println();
    Serial.println("EXAMPLES:");
    Serial.println("  setcal 2184.29321289 23198 16");
    Serial.println("  gain 1 (test with 1x gain temporarily)");
    Serial.println("  setgain 1 (set 1x gain permanently)");
    Serial.println("  measure 500 (detailed analysis with 500 samples)");
    Serial.println("================================\n");
}

void printStatus() {
    Serial.println("\n=== SYSTEM STATUS ===");
    Serial.printf("Scale: %s\n", liveData.scaleCalibrated ? "‚úì Calibrated" : "‚ùå Not calibrated");
    Serial.printf("Test active: %s\n", liveData.testActive ? "‚úì Yes" : "No");
    Serial.printf("Current force: %+.2f N\n", liveData.currentForce_N);
    Serial.printf("Current position: %.2f mm\n", liveData.currentPosition_mm);
    Serial.printf("Data points: %lu\n", totalDataPoints);
    Serial.printf("Buffer overflow: %s\n", liveData.bufferOverflow ? "‚ö†Ô∏è  Yes" : "No");
    Serial.printf("Sensor saturated: %s\n", liveData.sensorSaturated ? "‚ö†Ô∏è  Yes" : "No");
    Serial.printf("Scale error: %s\n", liveData.scaleError ? "‚ö†Ô∏è  Yes" : "No");
    
    if (liveData.scaleCalibrated) {
        Serial.printf("Cal Factor: %.8f\n", myScale.getCalibrationFactor());
        Serial.printf("Zero Offset: %ld\n", myScale.getZeroOffset());
    }
    
    // Memory info
    Serial.printf("Free heap: %lu bytes\n", esp_get_free_heap_size());
    Serial.println("=====================\n");
}

// ===== ADVANCED DIAGNOSTIC FUNCTIONS =====
void runSlowDiagnostics() {
    Serial.println("\n=== SLOW DIAGNOSTICS (30 samples over 3 seconds) ===");
    
    if (!liveData.scaleCalibrated) {
        Serial.println("Scale not initialized");
        return;
    }
    
    int successCount = 0;
    int timeoutCount = 0;
    int32_t readings[30];
    bool readingValid[30];
    
    Serial.println("Taking 30 readings with 100ms intervals...");
    
    for (int i = 0; i < 30; i++) {
        uint32_t startTime = millis();
        bool dataReady = false;
        
        // Wait up to 100ms for data
        while ((millis() - startTime < 100) && !dataReady) {
            if (myScale.available()) {
                readings[i] = myScale.getReading();
                readingValid[i] = true;
                successCount++;
                dataReady = true;
                Serial.printf("  %2d: %ld (%.1fms)\n", i+1, readings[i], (millis() - startTime));
            }
            delay(1);
        }
        
        if (!dataReady) {
            readings[i] = 0;
            readingValid[i] = false;
            timeoutCount++;
            Serial.printf("  %2d: TIMEOUT\n", i+1);
        }
        
        delay(100); // 100ms between attempts
    }
    
    Serial.printf("\nResults: %d successful, %d timeouts (%.1f%% success rate)\n", 
                  successCount, timeoutCount, (successCount * 100.0f) / 30);
    
    if (successCount > 5) {
        // Calculate statistics on valid readings
        int32_t minVal = readings[0], maxVal = readings[0], sum = 0;
        int validCount = 0;
        
        for (int i = 0; i < 30; i++) {
            if (readingValid[i]) {
                if (readings[i] < minVal) minVal = readings[i];
                if (readings[i] > maxVal) maxVal = readings[i];
                sum += readings[i];
                validCount++;
            }
        }
        
        int32_t average = sum / validCount;
        Serial.printf("Valid readings - Min: %ld, Max: %ld, Avg: %ld, Range: %ld\n", 
                      minVal, maxVal, average, maxVal - minVal);
                      
        if (successCount < 25) {
            Serial.println("‚ö†Ô∏è  HIGH FAILURE RATE - Check I2C connections and power");
        }
        if ((maxVal - minVal) > 50000) {
            Serial.println("‚ö†Ô∏è  HIGH VARIABILITY - Possible noise or hardware issues");
        }
    }
    
    Serial.println("=== SLOW DIAGNOSTICS COMPLETE ===\n");
}

void scanI2CDevices() {
    Serial.println("\n=== I2C DEVICE SCAN ===");
    
    int deviceCount = 0;
    for (uint8_t address = 1; address < 127; address++) {
        Wire.beginTransmission(address);
        uint8_t error = Wire.endTransmission();
        
        if (error == 0) {
            Serial.printf("Device found at 0x%02X", address);
            if (address == 0x2A) Serial.print(" (NAU7802 - CORRECT!)");
            Serial.println();
            deviceCount++;
        }
    }
    
    if (deviceCount == 0) {
        Serial.println("‚ùå No I2C devices found!");
        Serial.println("   Check wiring: SDA, SCL, Power, Ground");
    } else {
        Serial.printf("Found %d I2C device(s)\n", deviceCount);
        if (deviceCount > 1) {
            Serial.println("   Multiple devices - check for address conflicts");
        }
    }
    
    Serial.println("=== I2C SCAN COMPLETE ===\n");
}

void testI2CClockSpeeds() {
    Serial.println("\n=== I2C CLOCK SPEED TEST ===");
    
    uint32_t clockSpeeds[] = {100000, 400000};  // 100kHz, 400kHz
    const char* speedNames[] = {"100kHz", "400kHz"};
    
    for (int i = 0; i < 2; i++) {
        Serial.printf("Testing %s...\n", speedNames[i]);
        
        Wire.setClock(clockSpeeds[i]);
        delay(100);
        
        // Test basic communication
        Wire.beginTransmission(0x2A);
        uint8_t error = Wire.endTransmission();
        
        if (error == 0) {
            Serial.printf("  ‚úì Communication OK at %s\n", speedNames[i]);
            
            // Test a few readings
            int successCount = 0;
            for (int j = 0; j < 5; j++) {
                uint32_t startTime = millis();
                while (!myScale.available() && (millis() - startTime < 50)) {
                    delay(1);
                }
                if (myScale.available()) {
                    myScale.getReading();
                    successCount++;
                }
                delay(20);
            }
            Serial.printf("  Data readings: %d/5 successful\n", successCount);
        } else {
            Serial.printf("  ‚ùå Communication failed at %s (error: %d)\n", speedNames[i], error);
        }
    }
    
    // Reset to 400kHz
    Wire.setClock(400000);
    Serial.println("Reset to 400kHz");
    Serial.println("=== CLOCK SPEED TEST COMPLETE ===\n");
}

void performHardwareReset() {
    Serial.println("\n=== HARDWARE RESET ===");
    Serial.println("Performing NAU7802 hardware reset...");
    
    if (myScale.reset()) {
        Serial.println("‚úì Hardware reset successful");
        delay(500);
        
        // Reinitialize
        if (loadCell.initialize()) {
            Serial.println("‚úì Reinitialization successful");
            liveData.scaleCalibrated = loadCell.loadCalibration();
        } else {
            Serial.println("‚ùå Reinitialization failed");
            liveData.scaleCalibrated = false;
        }
    } else {
        Serial.println("‚ùå Hardware reset failed");
    }
    
    Serial.println("=== HARDWARE RESET COMPLETE ===\n");
}

void performPowerCycle() {
    Serial.println("\n=== POWER CYCLE TEST ===");
    Serial.println("Testing power down/up cycle...");
    
    if (myScale.powerDown()) {
        Serial.println("‚úì Powered down");
        delay(1000);
        
        if (myScale.powerUp()) {
            Serial.println("‚úì Powered up");
            delay(500);
            
            // Test communication
            Wire.beginTransmission(0x2A);
            if (Wire.endTransmission() == 0) {
                Serial.println("‚úì Communication restored");
                loadCell.configure();
            } else {
                Serial.println("‚ùå Communication failed after power up");
            }
        } else {
            Serial.println("‚ùå Power up failed");
        }
    } else {
        Serial.println("‚ùå Power down failed");
    }
    
    Serial.println("=== POWER CYCLE TEST COMPLETE ===\n");
}

void testDifferentGain(int gain) {
    Serial.printf("\n=== TESTING GAIN %dx ===\n", gain);
    
    // Set the requested gain
    bool gainSet = false;
    switch (gain) {
        case 1: gainSet = myScale.setGain(NAU7802_GAIN_1); break;
        case 2: gainSet = myScale.setGain(NAU7802_GAIN_2); break;
        case 4: gainSet = myScale.setGain(NAU7802_GAIN_4); break;
        case 8: gainSet = myScale.setGain(NAU7802_GAIN_8); break;
        case 16: gainSet = myScale.setGain(NAU7802_GAIN_16); break;
        case 32: gainSet = myScale.setGain(NAU7802_GAIN_32); break;
        case 64: gainSet = myScale.setGain(NAU7802_GAIN_64); break;
        case 128: gainSet = myScale.setGain(NAU7802_GAIN_128); break;
        default:
            Serial.printf("Invalid gain %d. Valid: 1,2,4,8,16,32,64,128\n", gain);
            return;
    }
    
    if (!gainSet) {
        Serial.printf("‚ùå Failed to set gain to %dx\n", gain);
        return;
    }
    
    // MUST recalibrate AFE after gain change
    if (!myScale.calibrateAFE()) {
        Serial.println("‚ùå AFE calibration failed");
        return;
    }
    
    Serial.printf("‚úì Gain set to %dx and AFE recalibrated\n", gain);
    delay(500); // Let it stabilize
    
    // Test readings at this gain
    Serial.println("Testing 5 readings...");
    int successCount = 0;
    
    for (int i = 0; i < 5; i++) {
        uint32_t startTime = millis();
        while (!myScale.available() && (millis() - startTime < 100)) {
            delay(1);
        }
        
        if (myScale.available()) {
            int32_t reading = myScale.getReading();
            Serial.printf("  %d: %ld\n", i+1, reading);
            successCount++;
        } else {
            Serial.printf("  %d: TIMEOUT\n", i+1);
        }
        delay(100);
    }
    
    Serial.printf("Success rate: %d/5 (%.0f%%)\n", successCount, (successCount * 100.0f) / 5);
    
    Serial.printf("=== GAIN %dx TEST COMPLETE ===\n\n", gain);
    Serial.println("NOTE: This was a test only. Use 'setgain' command to permanently change gain.");
    
    // Reset to default gain
    myScale.setGain(NAU7802_GAIN_16);
    myScale.calibrateAFE();
    Serial.println("Reset to 16x gain");
}

void setGainPermanently(int gain) {
    Serial.printf("\n=== SETTING GAIN TO %dx PERMANENTLY ===\n", gain);
    
    // Set the requested gain
    bool gainSet = false;
    switch (gain) {
        case 1: gainSet = myScale.setGain(NAU7802_GAIN_1); break;
        case 2: gainSet = myScale.setGain(NAU7802_GAIN_2); break;
        case 4: gainSet = myScale.setGain(NAU7802_GAIN_4); break;
        case 8: gainSet = myScale.setGain(NAU7802_GAIN_8); break;
        case 16: gainSet = myScale.setGain(NAU7802_GAIN_16); break;
        case 32: gainSet = myScale.setGain(NAU7802_GAIN_32); break;
        case 64: gainSet = myScale.setGain(NAU7802_GAIN_64); break;
        case 128: gainSet = myScale.setGain(NAU7802_GAIN_128); break;
        default:
            Serial.printf("Invalid gain %d. Valid: 1,2,4,8,16,32,64,128\n", gain);
            return;
    }
    
    if (!gainSet) {
        Serial.printf("‚ùå Failed to set gain to %dx\n", gain);
        return;
    }
    
    // MUST recalibrate AFE after gain change
    if (!myScale.calibrateAFE()) {
        Serial.println("‚ùå AFE calibration failed");
        // Don't return - still try to save the setting
    } else {
        Serial.println("‚úì AFE recalibrated");
    }
    
    Serial.printf("‚úì Gain permanently set to %dx\n", gain);
    Serial.println("‚ö†Ô∏è  IMPORTANT: You should recalibrate the scale after changing gain!");
    Serial.println("Use 'tare' then 'calibrate' commands to recalibrate.");
    
    delay(500); // Let it stabilize
    
    // Test a few readings
    Serial.println("Testing 3 readings with new gain...");
    for (int i = 0; i < 3; i++) {
        uint32_t startTime = millis();
        while (!myScale.available() && (millis() - startTime < 100)) {
            delay(1);
        }
        
        if (myScale.available()) {
            int32_t reading = myScale.getReading();
            Serial.printf("  Raw reading %d: %ld\n", i+1, reading);
        } else {
            Serial.printf("  Reading %d: TIMEOUT\n", i+1);
        }
        delay(200);
    }
    
    Serial.printf("=== GAIN %dx SET PERMANENTLY ===\n\n", gain);
}

void testTensionCompression() {
    Serial.println("\n=== TENSION/COMPRESSION TEST ===");
    
    if (!liveData.scaleCalibrated) {
        Serial.println("‚ùå Scale not calibrated");
        return;
    }
    
    Serial.println("This test helps verify your load cell works in both directions");
    Serial.println("Press Enter to continue...");
    
    while (Serial.available()) Serial.read();
    while (Serial.available() == 0) delay(10);
    
    Serial.println("\n1. ZERO TEST");
    Serial.println("Remove all loads from the load cell");
    Serial.println("Press Enter when ready...");
    
    while (Serial.available()) Serial.read();
    while (Serial.available() == 0) delay(10);
    
    delay(500);
    float zeroReading = loadCell.getWeight();
    Serial.printf("Zero reading: %.3f kg\n", zeroReading);
    
    Serial.println("\n2. TENSION TEST");
    Serial.println("Apply tension (hang a weight or pull)");
    Serial.println("Press Enter when load is applied...");
    
    while (Serial.available()) Serial.read();
    while (Serial.available() == 0) delay(10);
    
    delay(500);
    float tensionReading = loadCell.getWeight();
    Serial.printf("Tension reading: %.3f kg\n", tensionReading);
    
    if (tensionReading > zeroReading + 0.1) {
        Serial.println("‚úì TENSION: Positive direction working");
    } else {
        Serial.println("‚ùå TENSION: No positive change detected");
    }
    
    Serial.println("\n3. COMPRESSION TEST");
    Serial.println("Apply compression (push down or place weight)");
    Serial.println("Press Enter when load is applied...");
    
    while (Serial.available()) Serial.read();
    while (Serial.available() == 0) delay(10);
    
    delay(500);
    float compressionReading = loadCell.getWeight();
    Serial.printf("Compression reading: %.3f kg\n", compressionReading);
    
    if (compressionReading < zeroReading - 0.1) {
        Serial.println("‚úì COMPRESSION: Negative direction working");
    } else {
        Serial.println("‚ùå COMPRESSION: No negative change detected");
    }
    
    Serial.println("\n=== SUMMARY ===");
    Serial.printf("Zero: %.3f kg\n", zeroReading);
    Serial.printf("Tension: %.3f kg (change: %+.3f)\n", tensionReading, tensionReading - zeroReading);
    Serial.printf("Compression: %.3f kg (change: %+.3f)\n", compressionReading, compressionReading - zeroReading);
    
    bool tensionWorking = (tensionReading > zeroReading + 0.1);
    bool compressionWorking = (compressionReading < zeroReading - 0.1);
    
    if (tensionWorking && compressionWorking) {
        Serial.println("‚úì BOTH DIRECTIONS WORKING - Load cell properly calibrated!");
    } else if (tensionWorking) {
        Serial.println("‚ö†Ô∏è  Only tension working - check compression setup");
    } else if (compressionWorking) {
        Serial.println("‚ö†Ô∏è  Only compression working - check tension setup");
    } else {
        Serial.println("‚ùå Neither direction working properly - check calibration");
    }
    
    Serial.println("=== TEST COMPLETE ===\n");
}

void runMeasurementTest(int numSamples) {
    Serial.printf("\n=== MEASUREMENT ACCURACY TEST (%d samples) ===\n", numSamples);
    
    if (!liveData.scaleCalibrated) {
        Serial.println("‚ùå Scale not calibrated");
        return;
    }
    
    if (numSamples > 1000) {
        Serial.println("‚ö†Ô∏è  Limiting to 1000 samples for memory");
        numSamples = 1000;
    }
    
    Serial.println("This test analyzes measurement precision and stability");
    Serial.println("Keep load constant during the test for best results");
    Serial.println("Press Enter to start...");
    
    while (Serial.available()) Serial.read();
    while (Serial.available() == 0) delay(10);
    
    // Allocate arrays for data
    float* weights = new float[numSamples];
    int32_t* rawReadings = new int32_t[numSamples];
    uint32_t* timestamps = new uint32_t[numSamples];
    
    if (!weights || !rawReadings || !timestamps) {
        Serial.println("‚ùå Memory allocation failed");
        return;
    }
    
    Serial.printf("Collecting %d samples (50ms intervals)...\n", numSamples);
    
    int validSamples = 0;
    uint32_t startTime = millis();
    
    // Get calibration values once (they shouldn't change during test)
    int32_t zeroOffset = myScale.getZeroOffset();
    float calibrationFactor = myScale.getCalibrationFactor();
    
    Serial.printf("Using: Zero offset = %ld, Cal factor = %.8f\n", zeroOffset, calibrationFactor);
    
    for (int i = 0; i < numSamples; i++) {
        uint32_t sampleStart = millis();
        
        // Wait for scale data
        int attempts = 0;
        while (!myScale.available() && attempts < 100) {
            delay(1);
            attempts++;
        }
        
        if (myScale.available()) {
            // FIXED: Only call getReading() ONCE, then calculate weight manually
            int32_t rawReading = myScale.getReading();
            rawReadings[validSamples] = rawReading;
            
            // Calculate weight manually from the SAME raw reading
            if (calibrationFactor != 0.0f && calibrationFactor != 1.0f) {
                weights[validSamples] = (float)(rawReading - zeroOffset) / calibrationFactor;
            } else {
                weights[validSamples] = 0.0f;
            }
            
            timestamps[validSamples] = millis() - startTime;
            validSamples++;
            
            // Progress indicator
            if (i % 20 == 0) {
                Serial.printf("  Progress: %d/%d (%.1f%%) - Raw: %ld, Weight: %.3f\n", 
                             i+1, numSamples, ((i+1) * 100.0f) / numSamples, 
                             rawReading, weights[validSamples-1]);
            }
        } else {
            Serial.printf("  Sample %d: TIMEOUT\n", i+1);
        }
        
        // Wait for 50ms interval
        while (millis() - sampleStart < 50) {
            delay(1);
        }
    }
    
    if (validSamples < 10) {
        Serial.println("‚ùå Too few valid samples for analysis");
        delete[] weights;
        delete[] rawReadings;
        delete[] timestamps;
        return;
    }
    
    // Calculate statistics
    float weightSum = 0, rawSum = 0;
    float weightMin = weights[0], weightMax = weights[0];
    int32_t rawMin = rawReadings[0], rawMax = rawReadings[0];
    
    for (int i = 0; i < validSamples; i++) {
        weightSum += weights[i];
        rawSum += rawReadings[i];
        
        if (weights[i] < weightMin) weightMin = weights[i];
        if (weights[i] > weightMax) weightMax = weights[i];
        if (rawReadings[i] < rawMin) rawMin = rawReadings[i];
        if (rawReadings[i] > rawMax) rawMax = rawReadings[i];
    }
    
    float weightMean = weightSum / validSamples;
    float rawMean = rawSum / validSamples;
    
    // Calculate standard deviation
    float weightVariance = 0, rawVariance = 0;
    for (int i = 0; i < validSamples; i++) {
        float weightDiff = weights[i] - weightMean;
        float rawDiff = rawReadings[i] - rawMean;
        weightVariance += weightDiff * weightDiff;
        rawVariance += rawDiff * rawDiff;
    }
    
    float weightStdDev = sqrt(weightVariance / validSamples);
    float rawStdDev = sqrt(rawVariance / validSamples);
    
    // Calculate resolution and precision
    float weightRange = weightMax - weightMin;
    float rawRange = rawMax - rawMin;
    float measurementTime = timestamps[validSamples-1] / 1000.0f;
    
    // Print comprehensive analysis
    Serial.println("\n=== MEASUREMENT ANALYSIS ===");
    Serial.printf("Valid samples: %d/%d (%.1f%% success rate)\n", 
                  validSamples, numSamples, (validSamples * 100.0f) / numSamples);
    Serial.printf("Test duration: %.2f seconds\n", measurementTime);
    Serial.printf("Sample rate: %.1f Hz\n", validSamples / measurementTime);
    
    Serial.println("\n--- CALIBRATED MEASUREMENTS ---");
    Serial.printf("Mean weight: %+.6f kg (%+.3f N)\n", weightMean, weightMean * 9.81f);
    Serial.printf("Min weight:  %+.6f kg (%+.3f N)\n", weightMin, weightMin * 9.81f);
    Serial.printf("Max weight:  %+.6f kg (%+.3f N)\n", weightMax, weightMax * 9.81f);
    Serial.printf("Range:       %.6f kg (%.3f N)\n", weightRange, weightRange * 9.81f);
    Serial.printf("Std Dev:     %.6f kg (%.3f N)\n", weightStdDev, weightStdDev * 9.81f);
    
    // Precision analysis
    if (abs(weightMean) > 0.001) {
        float precisionPercent = (weightStdDev / abs(weightMean)) * 100.0f;
        Serial.printf("Precision:   %.6f%% of reading\n", precisionPercent);
        
        if (precisionPercent < 0.1) {
            Serial.println("‚úì EXCELLENT precision (<0.1%)");
        } else if (precisionPercent < 0.5) {
            Serial.println("‚úì GOOD precision (<0.5%)");
        } else if (precisionPercent < 1.0) {
            Serial.println("‚ö†Ô∏è  FAIR precision (<1.0%)");
        } else {
            Serial.println("‚ùå POOR precision (>1.0%)");
        }
    } else {
        Serial.println("Zero load - precision measured as absolute noise");
    }
    
    Serial.println("\n--- RAW ADC MEASUREMENTS ---");
    Serial.printf("Mean ADC:    %ld counts\n", (int32_t)rawMean);
    Serial.printf("Min ADC:     %ld counts\n", rawMin);
    Serial.printf("Max ADC:     %ld counts\n", rawMax);
    Serial.printf("Range:       %ld counts\n", rawMax - rawMin);
    Serial.printf("Std Dev:     %.1f counts\n", rawStdDev);
    
    // Resolution analysis
    float effectiveBits = log2(16777216.0f / rawStdDev); // 24-bit ADC = 2^24
    Serial.printf("Effective resolution: %.1f bits (of 24-bit ADC)\n", effectiveBits);
    
    if (effectiveBits > 20) {
        Serial.println("‚úì EXCELLENT ADC resolution");
    } else if (effectiveBits > 18) {
        Serial.println("‚úì GOOD ADC resolution");
    } else if (effectiveBits > 16) {
        Serial.println("‚ö†Ô∏è  FAIR ADC resolution");
    } else {
        Serial.println("‚ùå POOR ADC resolution - check for noise");
    }
    
    // Stability analysis
    Serial.println("\n--- STABILITY ANALYSIS ---");
    int stableCount = 0;
    float tolerance = weightStdDev * 2; // 2-sigma tolerance
    
    for (int i = 0; i < validSamples; i++) {
        if (abs(weights[i] - weightMean) <= tolerance) {
            stableCount++;
        }
    }
    
    float stabilityPercent = (stableCount * 100.0f) / validSamples;
    Serial.printf("Stable readings (¬±2œÉ): %d/%d (%.1f%%)\n", 
                  stableCount, validSamples, stabilityPercent);
    
    if (stabilityPercent > 95) {
        Serial.println("‚úì EXCELLENT stability");
    } else if (stabilityPercent > 90) {
        Serial.println("‚úì GOOD stability");
    } else if (stabilityPercent > 80) {
        Serial.println("‚ö†Ô∏è  FAIR stability");
    } else {
        Serial.println("‚ùå POOR stability - check for vibration/interference");
    }
    
    // Recommendations
    Serial.println("\n--- RECOMMENDATIONS ---");
    if (rawStdDev > 50) {
        Serial.println("‚Ä¢ High noise detected - check power supply and grounding");
    }
    if (weightStdDev > 0.001 && abs(weightMean) < 0.1) {
        Serial.println("‚Ä¢ Consider using lower gain for better stability at low loads");
    }
    if (validSamples < numSamples * 0.95) {
        Serial.println("‚Ä¢ Communication timeouts detected - check I2C connections");
    }
    
    // Export option
    Serial.println("\n--- DATA EXPORT ---");
    Serial.print("Export raw data? (y/n): ");
    
    while (Serial.available()) Serial.read();
    while (Serial.available() == 0) delay(10);
    char response = Serial.read();
    
    if (response == 'y' || response == 'Y') {
        Serial.println("\nCSV Data (Time_ms, Raw_ADC, Weight_kg, Force_N):");
        for (int i = 0; i < validSamples; i++) {
            Serial.printf("%lu,%ld,%.6f,%.3f\n", 
                         timestamps[i], rawReadings[i], weights[i], weights[i] * 9.81f);
        }
    }
    
    // Cleanup
    delete[] weights;
    delete[] rawReadings;
    delete[] timestamps;
    
    Serial.println("\n=== MEASUREMENT TEST COMPLETE ===\n");
}

// ===== SETUP FUNCTION =====
void setup() {
    Serial.begin(115200);
    delay(1000);
    Serial.println("\nüöÄ ESP32 Tensile Machine - Refactored Edition");
    Serial.println("===============================================");

    // Initialize EEPROM
    EEPROM.begin(EEPROM_SIZE);

    // Initialize Event Groups
    testEventFlags = xEventGroupCreate();
    if (testEventFlags == NULL) {
        Serial.println("‚ùå Failed to create event group!");
        while(1) delay(1000);
    }

    // GPIO initialization
    pinMode(STEP, OUTPUT);
    pinMode(DIR, OUTPUT);
    pinMode(EN, OUTPUT);
    digitalWrite(STEP, LOW);
    digitalWrite(DIR, HIGH);
    digitalWrite(EN, LOW);
    Serial.println("‚úì GPIO initialized");

    // Initialize load cell
    if (loadCell.initialize()) {
        liveData.scaleCalibrated = loadCell.loadCalibration();
        if (liveData.scaleCalibrated) {
            Serial.println("‚úì Load cell ready with saved calibration");
        } else {
            Serial.println("‚ö†Ô∏è  Load cell detected but needs calibration");
        }
    } else {
        Serial.println("‚ö†Ô∏è  Load cell not detected - continuing without");
        liveData.scaleCalibrated = false;
    }

    // Initialize display
    if (!display.begin(0x3C, true)) {
        Serial.println("‚ùå OLED initialization failed!");
    } else {
        Serial.println("‚úì OLED display initialized");
    }
    display.setRotation(1);
    display.setTextSize(1);
    display.setTextColor(SH110X_BLACK, SH110X_WHITE);

    // Initialize buttons
    pinMode(BUTTON_A, INPUT_PULLUP);
    pinMode(BUTTON_B, INPUT_PULLUP);
    pinMode(BUTTON_C, INPUT_PULLUP);
    Serial.println("‚úì Buttons initialized");

    // Create tasks
    xTaskCreatePinnedToCore(dataAcquisitionTask, "DataTask", 8192, NULL, 2, &dataTaskHandle, 1);
    xTaskCreatePinnedToCore(uiTask, "UITask", 8192, NULL, 1, &uiTaskHandle, 1);
    
    Serial.println("‚úì Tasks created successfully");
    Serial.println("\nüéØ System ready! Use 'help' for commands");
    
    if (!liveData.scaleCalibrated) {
        Serial.println("\nüìù QUICK START:");
        Serial.println("1. Type 'diag' to check load cell");
        Serial.println("2. Type 'calibrate' to calibrate");
        Serial.println("3. Use menu system for testing");
    }
    Serial.println();
}

// ===== MAIN LOOP =====
void loop() {
    static unsigned long lastScaleRead = 0;
    const unsigned long scaleReadInterval = 50; // Read scale every 50ms (20Hz)
    
    // Handle scale reading on Core 0 (away from timer interrupts)
    if (liveData.scaleCalibrated && (millis() - lastScaleRead >= scaleReadInterval)) {
        float newForce = loadCell.getForceN();
        if (newForce != 0.0f || !liveData.testActive) { // Update if valid reading or not testing
            liveData.currentForce_N = newForce;
            
            // Track peak force during testing
            if (liveData.testActive && newForce > liveData.peakForce_N) {
                liveData.peakForce_N = newForce;
            }
        }
        lastScaleRead = millis();
    }
    
    // Handle tare requests (moved from data acquisition task)
    EventBits_t bits = xEventGroupGetBits(testEventFlags);
    if (bits & EVT_TARE_REQUEST) {
        loadCell.tare();
        xEventGroupClearBits(testEventFlags, EVT_TARE_REQUEST);
    }
    
    // Handle serial commands
    if (Serial.available()) {
        String command = Serial.readStringUntil('\n');
        handleSerialCommand(command);
    }
    
    // Main loop runs on Core 0 - keep it light but handle scale reading
    vTaskDelay(pdMS_TO_TICKS(10)); // 10ms delay = 100Hz loop rate
}
